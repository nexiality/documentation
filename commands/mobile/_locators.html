<style>
  .locators.tabs { padding: 5px; }

  .locators.tabs li { margin-bottom: 0 !important; }

  .tab-links code { background-image: none; padding: 2px; }

  #tab_title_tag, #tab_title_class, #tab_title_css {
    background:  #aaa !important;
    color:       #555 !important;
    font-weight: normal !important;
    padding:     15px 15px 3px 15px !important;
  }

  .active #tab_title_tag, .active #tab_title_class, .active #tab_title_css {
    text-shadow: none;
    box-shadow:  2px 0 5px #888 !important;
  }
</style>

<div class="tabs locators">
    <ul class="tab-links tabs-collapsed">
        <li><a href="#tab_id" id="tab_title_id">ID</a></li>
        <li><a href="#tab_a11y" id="tab_title_a11y">Accessibility ID</a></li>
        <li><a href="#tab_xpath" id="tab_title_xpath">XPath</a></li>
        <li><a href="#tab_name" id="tab_title_name">Name</a></li>
        <li><a href="#tab_res" id="tab_title_res">Resource ID</a></li>
        <li><a href="#tab_predicate" id="tab_title_predicate">Predicate</a></li>
        <li><a href="#tab_cc" id="tab_title_cc">Class Chain</a></li>
        <li><a href="#tab_image" id="tab_title_image">Image</a></li>
        <li><a href="#tab_link" id="tab_title_link">Link Text</a></li>
        <li><a href="#tab_partialLinkText" id="tab_title_partialLinkText">Partial Link Text</a></li>
        <li><a href="#tab_text" id="tab_title_text">Text</a></li>
        <li><a href="#tab_nearby" id="tab_title_nearby">Nearby</a></li>
        <li><a href="#tab_oneof" id="tab_title_oneof">"One Of"</a></li>
        <li><a href="#tab_tag" id="tab_title_tag">Tag</a></li>
        <li><a href="#tab_class" id="tab_title_class">Style Class</a></li>
        <li><a href="#tab_css" id="tab_title_css">CSS</a></li>
    </ul>
    <div class="tab-content">
        <div id="tab_id" class="tab">
            Quick Tip: ID locators are prefixed by <code>id=</code><br/>
            <br/>
            Reference an element by its ID is, by far, the simplest type of locator. Unfortunately, just like its web
            counterpart, the "ID" in reference isn't always unique as one would hope. For simpler applications, this
            locator usually works well. For more complex applications where an "ID" might be repeated across multiple
            elements, a different locator strategy (such as XPATH) might be a better way to go.<br/>
            <br/>
            For Android applications, the "resource-id" property is also considered as an "ID". One can use either the
            <code>id=...</code> or <code>res=...</code> syntax. Here's an example of finding an "ID" of an element via
            the Appium inspector:<br/>
            <img src="image/locator_01.png"/><br/>
            <br/>
            For the above example, one may express this locator as:
            <ul>
                <li><code>id=com.google.android.calculator:id/digit_5</code></li>
                <li><code>res=com.google.android.calculator:id/digit_5</code></li>
            </ul>
            In contrast, iOS automation uses the "name" property as the "ID". Note that there isn't an actual property
            named "ID" or "id". However, one may use either <code>id=...</code> or <code>name=...</code> syntax.
            Nexial will appropriately resolve it to the correct type of locator.<br/>
            <img src="image/locator_02.png"/><br/>
            <br/>
            For the above example, one may express this locator as:
            <ul>
                <li><code>id=Remind me on a day</code></li>
                <li><code>name=Remind me on a day</code></li>
            </ul>
        </div>

        <div id="tab_a11y" class="tab">
            Quick Tip: Accessibility ID locators are prefixed by <code>a11y=</code><br/>
            <br/>
            The design purpose of an accessibility ID is to improve usability for users with visual or hearing
            impairments. Accessibility tools like screen readers or TTS software utilize these IDs to provide additional
            usability support. From the test automation standpoint, the same accessibility ID can be utilized as the
            basis for identifying an element. As a convenience, Nexial recognizes a locator by accessibility ID via the
            <code>a11y</code> prefix (there are 11 characters between <code>a</code> and <code>y</code> of
            <code>accessibility</code>).<br/>
            <br/>
            On Android, this locator strategy uses <code>contentDescription</code> or <code>content-desc</code>
            property:<br/>
            <img src="image/locator_03.png"/><br/>
            <br/>
            For the above example, the locator would be <code>a11y=Dark theme</code>.<br/>
            <br/>
            On iOS, the accessibility id, the id, and the name locator strategies are all identical. Behind the scene,
            they are implemented the same way.<br/>
            <img src="image/locator_04.png"/><br/>
            <br/>
            For the above example, one would specify this locator as <code>a11y=Back</code>.<br/>
            <br/>
            Generally speaking, it is preferred to use the accessibility ID over ID (although on iOS they are the same)
            because the accessibility ID is:
            <ol>
                <li>beneficial to both testers and users with visual or hearing impairment.</li>
                <li>generally more readable than plain ID.</li>
            </ol>
        </div>

        <div id="tab_xpath" class="tab">
            Quick Tip: XPATH locators are prefixed by <code>xpath=</code> or without any prefixes.<br/>
            <br/>
            The tried and true XPATH locator is available for mobile automation, as in the case of web or desktop
            automation. And as it is in the case of other automation uses, XPATH is both powerful and potentially
            troublesome.<br/>
            <br/>
            With XPATH, one can search for an element via its hierarchy, its attributes, and its text. Whereas the power
            lies, so is the danger thereof (
            <a href="https://en.wikipedia.org/wiki/With_great_power_comes_great_responsibility" class="external-link"
               target="_nexial_link">Peter Parker principle</a>).<br/>
            <br/>
            It is often prudent <b>NOT</b> to use the XPATH locator provided by the Appium inspector. Instead, one
            should put some effort into simplifying it. For example,<br/>
            <img src="image/locator_05.png"/><br/>
            <br/>
            The provided/suggested XPATH for the "Connected devices" link is as follows (broken into lines for
            readability):
            <pre>/hierarchy/android.widget.FrameLayout
  /android.widget.LinearLayout
    /android.widget.FrameLayout
      /android.view.ViewGroup
        /android.widget.ScrollView
          /android.widget.LinearLayout
            /android.widget.FrameLayout[2]
              /android.widget.LinearLayout
                /android.widget.FrameLayout
                  /androidx.recyclerview.widget.RecyclerView
                    /android.widget.LinearLayout[2]
                      /android.widget.RelativeLayout
                        /android.widget.TextView[1]</pre>
            Surely this would work (since Appium provides this). It is also incredibly difficult to decipher and to
            maintain. Instead, one could reduce this to something like:
            <ul>
                <li><code>//android.widget.TextView[@text='Connected devices']</code></li>
                <li><code>//*[@text='Connected devices']</code></li>
            </ul>
            The benefits of optimizing the XPATH are:
            <ol>
                <li>Easier to read, hence easier to maintain</li>
                <li>No longer dependent on the hierarchy or placements of UI elements</li>
                <li>Potentially faster than the long-winded version</li>
            </ol>
            To use the XPATH locator in Nexial, simply use the XPATH as is or prefix it with <code>xpath=</code>.
        </div>

        <div id="tab_name" class="tab">
            Quick Tip: Name locators are prefixed by <code>name=</code><br/>
            <br/>
            <b>Only applicable for iOS automation</b>. Alias to the ID locator. See <a href="#tab_id">ID locator</a>
            for more details.
        </div>

        <div id="tab_res" class="tab">
            Quick Tip: Resource ID locators are prefixed by <code>res=</code><br/>
            <br/>
            <b>Only applicable for Android automation</b>. Alias to the ID locator. See <a href="#tab_id">ID locator</a>
            for more details.
        </div>

        <div id="tab_predicate" class="tab">
            Quick Tip: Predicate locators are prefixed by <code>predicate=</code><br/>
            <br/>
            <b>Only applicable for iOS automation</b>. Also known as <code>-ios predicate string</code>. This type
            of locator represents a recursive element search using the iOS Predicate (iOS 10.0 and above). The syntax
            is similar to the XPATH query but comes with its own set of logical and comparative operators. While this type
            of locator is powerful, one would essentially be writing another "mini" query language. Consult the
            following links for more details:
            <ul>
                <li>
                    <a href="https://appium.io/docs/en/writing-running-appium/ios/ios-predicate/">https://appium.io/docs/en/writing-running-appium/ios/ios-predicate/</a>
                </li>
                <li>
                    <a href="https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/ios/ios-predicate.md">https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/ios/ios-predicate.md</a>
                </li>
                <li>
                    <a href="https://developer.apple.com/documentation/foundation/nspredicate">https://developer.apple.com/documentation/foundation/nspredicate</a>
                </li>
            </ul>
            Since this only works on iOS and has a dependency on the underlying iOS object model, this form of
            identifying elements should not be considered as the first choice. Nonetheless, at times the iOS-specific
            technique might be the only viable option.<br/>
            <br/>
            For this type of locator, prefix it with <code>predicate=</code>.
        </div>

        <div id="tab_cc" class="tab">
            Quick Tip: Class Chain locators are prefixed by <code>cc=</code><br/>
            <br/>
            <b>Only applicable for iOS automation</b>. This type of locator strategy is designed to replace XPATH
            (albeit only available on iOS platform) to quickly locate hierarchical elements. It is possible to use class
            chain (from this point, <code>cc</code>) to search for direct child element using <code>/</code> or
            search for descendent elements using <code>**/</code> syntax. Filter criteria should be enclosed within
            back tick (<code>`...`</code>) for matching predicate, and enclosed within dollar (<code>$...$</code>) for
            containing predicates. For example, the following XPATH:<br/>
            <pre>//XCUIElementTypeTable[@name="table"]/XCUIElementTypeCell[@visible="true" and .//XCUIElementTypeTextField[@name="input]]</pre>
            ... would be translated into <cod>cc</cod> locator like this:<br/>
            <pre>
**/XCUIElementTypeTable[`name == "table"`]/XCUIElementTypeCell[`visible == 1`][$type == "XCUIElementTypeTextField" AND name == "input"$]<font
                    color="#aaa">
\_____________________/\_________________/\__________________/\______________/\________________________________________________________/</font><font
                    color="#ccf">

 find an
 "XCUIElementTypeTable"  that has an
 element...              attribute named
                         "name" with value
                         equals to "table"   followed by an
                                             "XCUIElementTypeCell"
                                             cell...            that is visible  and it <b><u>contains</u></b> under its hierarchy
                                                                                 another element of type "XCUIElementTypeTextField"
                                                                                 which has an attribute called "name" with value equals
                                                                                 to "input".</font></pre>
            <br/>
            While not necessarily less verbose than its XPATH counterpart, <code>cc</code> locator promised to be more
            performant without losing much of the flexibility found in XPATH. Here are a few more examples,<br>
            <ul>
                <li><code>XCUIElementTypeWindow[2]</code> - selects the second window in the hierarchy.</li>
                <li><code>XCUIElementTypeWindow[label BEGINSWITH “foo”][-1]</code> - selects the last window whose
                    label begins with <code>foo</code>.
                </li>
                <li><code>**/XCUIElementTypeCell[name BEGINSWITH "C"]/XCUIElementTypeButton[10]</code> - selects the
                    10th child button of the first cell in the tree whose name starts with <code>C</code> and which
                    has at least ten direct children of type <code>XCUIElementTypeButton</code>.
                </li>
            </ul>
            One may use Appium inspector to find a suitable <code>cc</code> locator for an iOS device.<br/>
            <br/>
            For more details about the class chain queries, please visit:
            <ul>
                <li>
                    <a href="https://github.com/facebookarchive/WebDriverAgent/wiki/Class-Chain-Queries-Construction-Rules"
                       class="external-link" target="_nexial_link">https://github.com/facebookarchive/WebDriverAgent/wiki/Class-Chain-Queries-Construction-Rules</a>
                </li>
            </ul>
        </div>

        <div id="tab_link" class="tab">
            This form of locator is not available in mobile automation. However, one can use the
            <a href="clickByDisplayText(text)"><code>clickByDisplayText(text)</code></a> to achieve the same effect.
            Note
            that this command supports PolyMatcher, a flexible way to qualify the click target via its text. See the
            command for more details.
        </div>

        <div id="tab_partialLinkText" class="tab">
            This form of locator is not available in mobile automation. However, one can use the
            <a href="clickByDisplayText(text)"><code>clickByDisplayText(text)</code></a> to achieve the same effect.
            Note
            that this command supports PolyMatcher, a flexible way to qualify the click target via its text. See the
            command for more details.
        </div>

        <div id="tab_text" class="tab">
            Quick Tip: Text locators are prefixed by <code>text=</code><br/>
            <br/>
            This is a Nexial-only addition to the world of locators. The central idea here is to simplify automation
            by providing a simple way to reference an element that contains a unique string of text within the current
            application screen. For example,
            <pre>text=Enter your first name here</pre>
            ... references an element that contains an attribute named <code>text</code> with the value of
            <code>Enter your first name here</code>.<br/>
            <br/>
            In situations where one needs to automate a form on a mobile app, this type of locator might prove to be
            most useful. It is both easy to use and to decipher. This form of locator also supports PolyMatcher, which
            provides further expressiveness and flexibility. For example, to reference a component whose text starts
            with <code>Welcome home</code>, one can use the following text locator:<br/>
            <pre>text=START:Welcome home</pre>
            For more details on PolyMatcher, visit
            <a href="assertTextPresent(locator,text)"><code>assertTextPresent(locator,text)</code></a> and click on
            "PolyMatcher Enabled" link.<br/>
            <br/>
            Note that behind the scene, Nexial converts such locator to an XPATH-based locator.
        </div>

        <div id="tab_nearby" class="tab">
            Quick Tip: Nearby locators are prefixed by <code>nearby=</code><br/>
            <br/>
            This is a specialized locator (<em>only in Nexial!</em>) aimed to simplify the task of creating a locator.
            Instead of identifying an element via its attributes such as <code>content-desc</code>, <code>id</code>, or
            <code>accessibility id</code>, the <code>nearby</code> locator allows one to identify an element by its
            surrounding. Nexial takes care of translating to the appropriate reference during execution time and thus
            saving time during scripting. While this technique does not yield the same benefit in every scenario, it
            is often a great time saver and a significant reduction in the cost of maintaining automation artifacts.<br/>
            <br/>
            Let's consider the following example:<br/>
            <img src="image/locator_06.png"/><br/>
            To identity the text box, we would need to inspect its attributes (typically via Appium Inspector). With
            the <code>nearby</code> locator, we can simply specify it as: <code>nearby={below:Cellphone}</code> (reads:
            <em>Locate the element that is immediately below the element with text <code>Cellphone</code></em>). This
            simplified form is both easy to read and maintain.<br/>
            <br/>
            Here's another example:<br/>
            <img src="image/locator_07.png"><br/>
            The <code>nearby</code> locator to identify the "Male" radio button is simply
            <code>nearby={left-of:Male}</code>.<br/>
            <br/>
            In the above example, the radio buttons do not possess any visible text. Typically, one would need to
            construct suitable locators using these buttons' other attributes - likely with the help of Appium
            Inspector (or equivalent). With the <code>nearby</code> locator, we can use the "visible" surrounding of
            the element instead.<br/>
            <br/>
            Here's the syntax of this <code>nearby</code> locator:<br/>
            <pre style="margin-bottom:5px;">nearby={<span style="color:#0f9;">[relative-to]</span>:<span style="color:#09f;">[visible-text]</span>}{<span style="color:#9f0;">item:[index]</span>}{<span style="color:#f09;">attribute=value,attribute=value,...</span>}</pre>
            where,<br/>
            <table cellpadding="5" cellspacing="0">
            <tr>
                <th style="background-color:#303030;text-align:left">
                    <code style="color:#0f9;background-color:#303030;border:none">[relative-to]</code>
                </th>
                <td>
                    One of these values:
                    <ul>
                        <li>
                            <code>left-of</code> - indicates that the element of interest is to the left of the
                            <code>visible-text</code>
                        </li>
                        <li>
                            <code>right-of</code> - indicates that the element of interest is to the right of the
                            <code>visible-text</code>
                        </li>
                        <li>
                            <code>above</code> - indicates that the element of interest is above the
                            <code>visible-text</code>
                        </li>
                        <li>
                            <code>below</code> - indicates that the element of interest is below the
                            <code>visible-text</code>
                        </li>
                        <li>
                            <code>container</code> - indicates that the element of interest is the parent/container of
                            the <code>visible-text</code>, and that it is of the "group" type (such as
                            <code>android.view.ViewGroup</code>).
                        </li>
                        <li>
                            <code>scroll-container</code> - indicates that the element of interest is the
                            parent/container of the <code>visible-text</code>, and that it is of the "scrollable" type
                            (such as <code>android.widget.ScrollView</code>).
                        </li>
                    </ul>
                </td>
            </tr>
            <tr>
                <th style="background-color:#303030;text-align:left">
                    <code style="color:#09f;background-color:#303030;border:none">[visible-text]</code>
                </th>
                <td>The visible text is used to identify the target element.</td>
            </tr>
            <tr>
                <th style="background-color:#303030;text-align:left">
                    <code style="color:#9f0;background-color:#303030;border:none">item:...</code>
                </th>
                <td>
                    In situations where there are multiple matches, one can specify the element index (as in, the
                    <em>nth</em> element) via the <code>item</code> keyword. The index must be a positive integer
                    (0-based), or the special keyword <code>last</code>. Use <code>item:last</code> to signify the last
                    match item.<br/>
                    <br/>
                    Consider the following example:<br/>
                    <img src="image/locator_08.png"/><br/>
                    <code>nearby={right-of:UNCHECKED}{index:1}</code> would reference the left-most checkbox and
                    <code>nearby={right-of:UNCHECKED}{index:last}</code> would reference the last (right-most) checkbox.
                </td>
            </tr>
            <tr>
                <th style="background-color:#303030;text-align:left">
                    <code style="color:#f09;background-color:#303030;border:none">attribute=value,...</code>
                </th>
                <td>
                    OPTIONAL. One can supply additional attributes of the target element to improve the locator
                    precision. This is generally not needed. At times when there are many elements nearby the same
                    text element, one may want to consider adding additional attributes to filter out the conflicting
                    elements.
                </td>
            </tr>
            </table>
        </div>

        <div id="tab_tag" class="tab">Not available in mobile automation.</div>

        <div id="tab_class" class="tab">Not available in mobile automation.</div>

        <div id="tab_css" class="tab">Not available in mobile automation.</div>

        <div id="tab_image" class="tab">
            Quick Tip: Image locators are prefixed by <code>image=</code><br/>
            <br/>
            <em>Coming soon, stay tuned!!</em>
        </div>

        <div id="tab_oneof" class="tab">
            Quick Tip: "One Of" locators are prefixed by <code>one-of=</code><br/>
            <br/>
            This is yet another Nexial-only, specialized locator aiming at simplifying platform-specific locator
            management. The main design idea is to allow one to specify multiple locators - some for a specific platform,
            while some as generalized locators - and allow Nexial to pick the best locator at runtime. With the
            <code>one-of</code> locator (more like <em>locators</em>), the multiple locators specified are filtered
            at execution time to the appropriate ones. This allows for cleaner automation scripts and a simpler way to
            maintain platform-specific or even build-specific locators. Here's an example to demonstrate this type of
            locator:<br/>
            <pre>one-of={text=Clear all}{android;id=dismiss_text}{ios;id=clear_all_button}</pre>
            The above read:
            <blockquote>
                First, look for a component whose <b>text is "Clear all"</b>. <br/>
                If that can't be found and the current device is <b>Android</b>, then look for a component with an
                <b>ID of "dismiss_text"</b>.<br/>
                However, if the current device is <b>iOS</b>, then look for a component with an
                <b>ID of "clear_all_button"</b>.
            </blockquote>
            The multiple decision points here are neatly synthesized into a series of <code>{...}{...}</code>. This
            simplifies the automation effort since we wouldn't need to maintain device-specific scripts or
            device-specific locators.<br/>
            <br/>
            It is noteworthy to state that the order of these "inner" locators is important. Nexial will filter out all
            the irrelevant ones (<code>android</code> for iOS and <code>ios</code> for Android) and "test" the relevant
            ones from left to right. It is generally a good idea to order the most likely "inner" locator ahead of the
            other ones.<br/>
            <br/>
            Here's the syntax of this <code>one-of</code> locator:<br/>
            <pre style="margin-bottom:5px;">one-of={<span style="color:#09f">[android|ios];</span><span style="color:#0f9">[locator]</span>}{<span style="color:#0f9">[locator]</span>}{<span style="color:#0f9">[locator]</span>}...</pre>
            where,
            <table cellpadding="5" cellspacing="0">
            <tr>
                <th style="background-color:#303030;text-align:left">
                    <code style="color:#09f;background-color:#303030;border:none">[android|ios];</code>
                </th>
                <td>
                    <code>android</code> or <code>ios</code> - each specified locator may be prefixed with
                    <code>android</code> or <code>ios</code> to signify its platform/device dependency. During
                    execution, Nexial will filter out the irrelevant locator(s) based on this. Note that this must be
                    suffixed with a semi-colon. For example: <code>{android<b>;</b>id=FirstName}</code>
                </td>
            </tr>
                <tr>
                    <th style="background-color:#303030;text-align:left">
                        <code style="color:#0f9;background-color:#303030;border:none">[locator]</code>
                    </th>
                    <td>
                        The device-specific or generalized locator. One may choose from any of the supported locators
                        such as ID, Accessibility ID, Text, etc.
                    </td>
                </tr>
            </table>
        </div>
    </div>
</div>
<br/>
